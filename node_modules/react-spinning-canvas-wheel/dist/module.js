import {jsx as $ePXfe$jsx} from "react/jsx-runtime";
import {useState as $ePXfe$useState, useRef as $ePXfe$useRef, useEffect as $ePXfe$useEffect, useCallback as $ePXfe$useCallback} from "react";

function $parcel$defineInteropFlag(a) {
  Object.defineProperty(a, '__esModule', {value: true, configurable: true});
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $522620a018af48fa$exports = {};

$parcel$defineInteropFlag($522620a018af48fa$exports);

$parcel$export($522620a018af48fa$exports, "default", () => $522620a018af48fa$export$2e2bcd8739ae039);


const $26175daef1698db1$var$getSegmentAngle = (segmentsCount)=>2 * Math.PI / segmentsCount
;
var $26175daef1698db1$export$2e2bcd8739ae039 = $26175daef1698db1$var$getSegmentAngle;


const $a59a1c7603902cc1$var$LINE_WIDTH = 4;
const $a59a1c7603902cc1$var$meanAngleDeg = (angle1, angle2)=>Math.atan2((Math.sin(angle1) + Math.sin(angle2)) / 2, (Math.cos(angle1) + Math.cos(angle2)) / 2)
;
const $a59a1c7603902cc1$var$getX = (offset, radius, angle)=>offset + radius * Math.sin(angle)
;
const $a59a1c7603902cc1$var$getY = (offset, radius, angle)=>offset + radius * Math.cos(angle)
;
const $a59a1c7603902cc1$var$drawWheel = ({ canvas: canvas , segments: segments , size: size , scale: scale , textFont: textFont , wheelColors: wheelColors  })=>{
    const ctx = canvas.getContext("2d");
    const radius = size / 2;
    const textOffset = 0.1 * radius;
    const segmentAngle = $26175daef1698db1$export$2e2bcd8739ae039(segments.length);
    canvas.width = size * scale;
    canvas.height = size * scale;
    ctx.scale(scale, scale);
    ctx.clearRect(0, 0, size, size);
    // circle background
    ctx.arc(radius, radius, radius, 0, 2 * Math.PI);
    ctx.fillStyle = wheelColors.wheelBackground;
    ctx.fill();
    // segments background
    for(let i = 0; i < segments.length; i += 1){
        const segment = segments[i];
        ctx.fillStyle = segment.backgroundColor || wheelColors.wheelBackground;
        ctx.strokeStyle = wheelColors.border;
        ctx.beginPath();
        ctx.arc(radius, radius, radius, segmentAngle * i, segmentAngle * (i + 1));
        ctx.lineTo(radius, radius);
        ctx.fill();
    }
    // circle border
    ctx.beginPath();
    ctx.arc(radius, radius, radius - $a59a1c7603902cc1$var$LINE_WIDTH / 2, 0, 2 * Math.PI);
    ctx.strokeStyle = wheelColors.border;
    ctx.lineWidth = $a59a1c7603902cc1$var$LINE_WIDTH;
    ctx.stroke();
    // segment borders
    ctx.beginPath();
    for(let i1 = 0; i1 < segments.length; i1 += 1){
        const fullSegmentAngle = -(i1 * segmentAngle) + Math.PI / 2;
        const lineX = $a59a1c7603902cc1$var$getX(radius, radius, fullSegmentAngle);
        const lineY = $a59a1c7603902cc1$var$getY(radius, radius, fullSegmentAngle);
        ctx.moveTo(lineX, lineY);
        ctx.lineTo(radius, radius);
    }
    ctx.stroke();
    // segments text
    ctx.font = textFont;
    for(let i2 = 0; i2 < segments.length; i2 += 1){
        const segment = segments[segments.length - 1 - i2];
        ctx.fillStyle = segment.textColor || wheelColors.text;
        const from = -(i2 * segmentAngle) + Math.PI / 2 + Math.PI;
        const to = -((i2 + 1) * segmentAngle) + Math.PI / 2 + Math.PI;
        const meanAngle = $a59a1c7603902cc1$var$meanAngleDeg(from, to);
        const textAngleRotation = meanAngle + Math.PI;
        const textAngle = -meanAngle;
        const textX = $a59a1c7603902cc1$var$getX(radius, radius - textOffset, textAngle);
        const textY = $a59a1c7603902cc1$var$getY(radius, radius - textOffset, textAngle);
        ctx.save();
        ctx.translate(textX, textY);
        ctx.rotate(textAngleRotation);
        ctx.rotate(Math.PI / 2);
        ctx.fillText(segment.title, 0, 4);
        ctx.restore();
    }
    return canvas;
};
var $a59a1c7603902cc1$export$2e2bcd8739ae039 = $a59a1c7603902cc1$var$drawWheel;


const $a76a40cb755a3958$var$rotateCanvas = ({ ctx: ctx , canvasToRender: canvasToRender , size: size , scale: scale , rotationAngle: rotationAngle  })=>{
    if (!ctx || !canvasToRender) return;
    const radius = size / 2;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(scale, scale);
    ctx.clearRect(0, 0, size, size);
    ctx.translate(radius, radius);
    ctx.rotate(rotationAngle);
    ctx.translate(-radius, -radius);
    ctx.drawImage(canvasToRender, 0, 0, size, size);
};
var $a76a40cb755a3958$export$2e2bcd8739ae039 = $a76a40cb755a3958$var$rotateCanvas;


// https://github.com/d3/d3-ease/blob/main/src/math.js
const $704659d096190daf$var$tpmt = (x)=>{
    return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
};
const $704659d096190daf$var$timingFunction = $704659d096190daf$var$tpmt;
var $704659d096190daf$export$2e2bcd8739ae039 = $704659d096190daf$var$timingFunction;



let $79cec7509a5d619b$var$canvas = null;
/**
 * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.
 *
 * @param {String} text The text to be rendered.
 * @param {String} font The css font descriptor that text is to be rendered with (e.g. "bold 14px verdana").
 *
 * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393
 */ const $79cec7509a5d619b$var$getTextWidth = (text, font)=>{
    if (!$79cec7509a5d619b$var$canvas) $79cec7509a5d619b$var$canvas = document.createElement('canvas');
    const context = $79cec7509a5d619b$var$canvas.getContext('2d');
    context.font = font;
    const metrics = context.measureText(text);
    return metrics.width;
};
var $79cec7509a5d619b$export$2e2bcd8739ae039 = $79cec7509a5d619b$var$getTextWidth;


const $17fa21843a4aa1a0$var$sliceTextByMaxWidth = (text, font, maxWidth)=>{
    const width = $79cec7509a5d619b$export$2e2bcd8739ae039(text, font);
    if (width < maxWidth) return text;
    let beginCursor = 0;
    let endCursor = text.length;
    let cursor = Math.floor(text.length / 2);
    // eslint-disable-next-line no-constant-condition
    while(true){
        const textSlice = `${text.slice(0, cursor)}...`;
        const w = $79cec7509a5d619b$export$2e2bcd8739ae039(textSlice, font);
        if (w > maxWidth) endCursor = cursor;
        else beginCursor = cursor;
        // middle between the beginCursor and the endCursor
        cursor = beginCursor + Math.floor((endCursor - beginCursor) / 2);
        if (beginCursor === cursor) return textSlice;
    }
};
var $17fa21843a4aa1a0$export$2e2bcd8739ae039 = $17fa21843a4aa1a0$var$sliceTextByMaxWidth;


const $e1dd2d1974fbf46b$var$getSegmentIndexByAngle = (/** Angle from 0 to Math.PI * 2 */ rotationAngle, segmentAngle)=>{
    // TODO:
    const normalizedAngle = Math.abs(rotationAngle % (Math.PI * 2) - Math.PI * 2) + Math.PI;
    return Math.floor(normalizedAngle % (Math.PI * 2) / segmentAngle);
};
var $e1dd2d1974fbf46b$export$2e2bcd8739ae039 = $e1dd2d1974fbf46b$var$getSegmentIndexByAngle;



const $ea86d140d248290c$var$getDevicePixelRatio = ()=>typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1
;
var $ea86d140d248290c$export$2e2bcd8739ae039 = $ea86d140d248290c$var$getDevicePixelRatio;


const $2c1e9e23e4a317be$var$useDevicePixelRatio = ()=>{
    const [scale, setScale] = $ePXfe$useState($ea86d140d248290c$export$2e2bcd8739ae039);
    $ePXfe$useEffect(()=>{
        const handleResize = ()=>setScale($ea86d140d248290c$export$2e2bcd8739ae039())
        ;
        window.addEventListener("resize", handleResize);
        return ()=>window.removeEventListener("resize", handleResize)
        ;
    }, []);
    return scale;
};
var $2c1e9e23e4a317be$export$2e2bcd8739ae039 = $2c1e9e23e4a317be$var$useDevicePixelRatio;


const $522620a018af48fa$var$GLOBAL_FONT = "Roboto, Helvetica, Arial, sans-serif";
const $522620a018af48fa$var$normalizeSegments = (segments, textFont, maxTextWidth)=>segments.map(({ title: title , ...rest })=>({
            title: $17fa21843a4aa1a0$export$2e2bcd8739ae039(title, textFont, maxTextWidth),
            ...rest
        })
    )
;
const $522620a018af48fa$var$getTextFont = (radius)=>`${0.06 * radius}px ${$522620a018af48fa$var$GLOBAL_FONT}`
;
const $522620a018af48fa$var$defaultWheelColors = {
    wheelBackground: "#fff",
    text: "rgba(0, 0, 0, 0.87)",
    border: "#424242"
};
const $522620a018af48fa$var$SpinningWheel = ({ size: size , segments: segments , wheelColors: wheelColors = $522620a018af48fa$var$defaultWheelColors , spinningWheelRef: spinningWheelRef , timingFunction: timingFunction = $704659d096190daf$export$2e2bcd8739ae039 , onSegmentChange: onSegmentChange = ()=>{
} , onSpinStart: onSpinStart = ()=>{
} , onSpinEnd: onSpinEnd = ()=>{
}  })=>{
    const [cachedWheel, setCachedWheel] = $ePXfe$useState(null);
    const cachedWheelRef = $ePXfe$useRef(null);
    cachedWheelRef.current = cachedWheel;
    const functions = $ePXfe$useRef({
        onSegmentChange: onSegmentChange,
        onSpinStart: onSpinStart,
        onSpinEnd: onSpinEnd
    });
    functions.current = {
        onSegmentChange: onSegmentChange,
        onSpinStart: onSpinStart,
        onSpinEnd: onSpinEnd
    };
    const rotationAngle = $ePXfe$useRef(0);
    const requestId = $ePXfe$useRef(null);
    const currentSegmentIndex = $ePXfe$useRef(0);
    const prevTime = $ePXfe$useRef(null);
    const fullTime = $ePXfe$useRef(0);
    const radius = size / 2;
    const scale = $2c1e9e23e4a317be$export$2e2bcd8739ae039();
    $ePXfe$useEffect(()=>{
        const canvas = document.createElement("canvas");
        const textFont = $522620a018af48fa$var$getTextFont(radius);
        const textMaxWidth = 0.675 * radius;
        const wheel = $a59a1c7603902cc1$export$2e2bcd8739ae039({
            canvas: canvas,
            segments: $522620a018af48fa$var$normalizeSegments(segments, textFont, textMaxWidth),
            size: size,
            scale: scale,
            textFont: textFont,
            wheelColors: wheelColors
        });
        setCachedWheel(wheel);
    }, [
        size,
        radius,
        segments,
        wheelColors,
        scale
    ]);
    // https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node
    const canvasRef = $ePXfe$useCallback((canvas)=>{
        if (!canvas || !cachedWheel) return;
        const ctx = canvas.getContext("2d");
        const segmentAngle = $26175daef1698db1$export$2e2bcd8739ae039(segments.length);
        canvas.width = size * scale;
        canvas.height = size * scale;
        if (requestId.current === null) window.requestAnimationFrame(()=>{
            $a76a40cb755a3958$export$2e2bcd8739ae039({
                ctx: ctx,
                canvasToRender: cachedWheel,
                size: size,
                scale: scale,
                rotationAngle: rotationAngle.current
            });
        });
        if (!spinningWheelRef) return;
        const animate = (secondsToSpin, speed)=>(time)=>{
                // first draw
                if (prevTime.current === null) {
                    currentSegmentIndex.current = $e1dd2d1974fbf46b$export$2e2bcd8739ae039(rotationAngle.current, segmentAngle);
                    prevTime.current = time;
                }
                const deltaTime = time - prevTime.current;
                prevTime.current = time;
                fullTime.current += deltaTime;
                if (fullTime.current > secondsToSpin * 1000) {
                    functions.current.onSpinEnd(currentSegmentIndex.current);
                    stopSpinning();
                    return;
                }
                const thisSegmentIndex = $e1dd2d1974fbf46b$export$2e2bcd8739ae039(rotationAngle.current, segmentAngle);
                if (currentSegmentIndex.current !== thisSegmentIndex) {
                    currentSegmentIndex.current = thisSegmentIndex;
                    functions.current.onSegmentChange(thisSegmentIndex);
                }
                // NOTE: in "variableI" letter "I" means UnitInterval - [0, 1)
                const timeI = fullTime.current / (secondsToSpin * 1000);
                const speedI = timingFunction(timeI);
                const deltaAngle = 2 * Math.PI / 360 * speedI * speed;
                rotationAngle.current += deltaAngle;
                $a76a40cb755a3958$export$2e2bcd8739ae039({
                    ctx: ctx,
                    canvasToRender: cachedWheelRef.current,
                    size: size,
                    scale: scale,
                    rotationAngle: rotationAngle.current
                });
                requestId.current = window.requestAnimationFrame(animate(secondsToSpin, speed));
            }
        ;
        function startSpinning(secondsToSpin, speed) {
            functions.current.onSpinStart();
            rotationAngle.current = 0;
            currentSegmentIndex.current = 0;
            prevTime.current = null;
            fullTime.current = 0;
            requestId.current = window.requestAnimationFrame(animate(secondsToSpin, speed));
        }
        function stopSpinning() {
            if (requestId.current) window.cancelAnimationFrame(requestId.current);
            requestId.current = null;
        }
        spinningWheelRef.current = {
            startSpinning: startSpinning,
            stopSpinning: stopSpinning
        };
    }, [
        cachedWheel
    ]);
    return(/*#__PURE__*/ $ePXfe$jsx("canvas", {
        width: size,
        height: size,
        style: {
            width: size,
            height: size
        },
        ref: canvasRef
    }));
};
var $522620a018af48fa$export$2e2bcd8739ae039 = $522620a018af48fa$var$SpinningWheel;



var $68417b47e79326a0$exports = {};




export {$522620a018af48fa$export$2e2bcd8739ae039 as default};
//# sourceMappingURL=module.js.map
