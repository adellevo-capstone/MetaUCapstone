var $hqOIc$reactjsxruntime = require("react/jsx-runtime");
var $hqOIc$react = require("react");

function $parcel$defineInteropFlag(a) {
  Object.defineProperty(a, '__esModule', {value: true, configurable: true});
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}

$parcel$defineInteropFlag(module.exports);

$parcel$export(module.exports, "default", () => $082c0c4a773616d1$export$2e2bcd8739ae039);
var $082c0c4a773616d1$exports = {};

$parcel$defineInteropFlag($082c0c4a773616d1$exports);

$parcel$export($082c0c4a773616d1$exports, "default", () => $082c0c4a773616d1$export$2e2bcd8739ae039);


const $77ad3b2cb2ddb8e0$var$getSegmentAngle = (segmentsCount)=>2 * Math.PI / segmentsCount
;
var $77ad3b2cb2ddb8e0$export$2e2bcd8739ae039 = $77ad3b2cb2ddb8e0$var$getSegmentAngle;


const $74c20d64a5d4a0af$var$LINE_WIDTH = 4;
const $74c20d64a5d4a0af$var$meanAngleDeg = (angle1, angle2)=>Math.atan2((Math.sin(angle1) + Math.sin(angle2)) / 2, (Math.cos(angle1) + Math.cos(angle2)) / 2)
;
const $74c20d64a5d4a0af$var$getX = (offset, radius, angle)=>offset + radius * Math.sin(angle)
;
const $74c20d64a5d4a0af$var$getY = (offset, radius, angle)=>offset + radius * Math.cos(angle)
;
const $74c20d64a5d4a0af$var$drawWheel = ({ canvas: canvas , segments: segments , size: size , scale: scale , textFont: textFont , wheelColors: wheelColors  })=>{
    const ctx = canvas.getContext("2d");
    const radius = size / 2;
    const textOffset = 0.1 * radius;
    const segmentAngle = $77ad3b2cb2ddb8e0$export$2e2bcd8739ae039(segments.length);
    canvas.width = size * scale;
    canvas.height = size * scale;
    ctx.scale(scale, scale);
    ctx.clearRect(0, 0, size, size);
    // circle background
    ctx.arc(radius, radius, radius, 0, 2 * Math.PI);
    ctx.fillStyle = wheelColors.wheelBackground;
    ctx.fill();
    // segments background
    for(let i = 0; i < segments.length; i += 1){
        const segment = segments[i];
        ctx.fillStyle = segment.backgroundColor || wheelColors.wheelBackground;
        ctx.strokeStyle = wheelColors.border;
        ctx.beginPath();
        ctx.arc(radius, radius, radius, segmentAngle * i, segmentAngle * (i + 1));
        ctx.lineTo(radius, radius);
        ctx.fill();
    }
    // circle border
    ctx.beginPath();
    ctx.arc(radius, radius, radius - $74c20d64a5d4a0af$var$LINE_WIDTH / 2, 0, 2 * Math.PI);
    ctx.strokeStyle = wheelColors.border;
    ctx.lineWidth = $74c20d64a5d4a0af$var$LINE_WIDTH;
    ctx.stroke();
    // segment borders
    ctx.beginPath();
    for(let i1 = 0; i1 < segments.length; i1 += 1){
        const fullSegmentAngle = -(i1 * segmentAngle) + Math.PI / 2;
        const lineX = $74c20d64a5d4a0af$var$getX(radius, radius, fullSegmentAngle);
        const lineY = $74c20d64a5d4a0af$var$getY(radius, radius, fullSegmentAngle);
        ctx.moveTo(lineX, lineY);
        ctx.lineTo(radius, radius);
    }
    ctx.stroke();
    // segments text
    ctx.font = textFont;
    for(let i2 = 0; i2 < segments.length; i2 += 1){
        const segment = segments[segments.length - 1 - i2];
        ctx.fillStyle = segment.textColor || wheelColors.text;
        const from = -(i2 * segmentAngle) + Math.PI / 2 + Math.PI;
        const to = -((i2 + 1) * segmentAngle) + Math.PI / 2 + Math.PI;
        const meanAngle = $74c20d64a5d4a0af$var$meanAngleDeg(from, to);
        const textAngleRotation = meanAngle + Math.PI;
        const textAngle = -meanAngle;
        const textX = $74c20d64a5d4a0af$var$getX(radius, radius - textOffset, textAngle);
        const textY = $74c20d64a5d4a0af$var$getY(radius, radius - textOffset, textAngle);
        ctx.save();
        ctx.translate(textX, textY);
        ctx.rotate(textAngleRotation);
        ctx.rotate(Math.PI / 2);
        ctx.fillText(segment.title, 0, 4);
        ctx.restore();
    }
    return canvas;
};
var $74c20d64a5d4a0af$export$2e2bcd8739ae039 = $74c20d64a5d4a0af$var$drawWheel;


const $746eff0e043c15c9$var$rotateCanvas = ({ ctx: ctx , canvasToRender: canvasToRender , size: size , scale: scale , rotationAngle: rotationAngle  })=>{
    if (!ctx || !canvasToRender) return;
    const radius = size / 2;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(scale, scale);
    ctx.clearRect(0, 0, size, size);
    ctx.translate(radius, radius);
    ctx.rotate(rotationAngle);
    ctx.translate(-radius, -radius);
    ctx.drawImage(canvasToRender, 0, 0, size, size);
};
var $746eff0e043c15c9$export$2e2bcd8739ae039 = $746eff0e043c15c9$var$rotateCanvas;


// https://github.com/d3/d3-ease/blob/main/src/math.js
const $e1f47da364eecfa1$var$tpmt = (x)=>{
    return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
};
// https://github.com/d3/d3-ease/blob/main/src/exp.js
const $e1f47da364eecfa1$var$expOut = (t)=>{
    return 1 - $e1f47da364eecfa1$var$tpmt(t);
};
const $e1f47da364eecfa1$var$timingFunction = $e1f47da364eecfa1$var$expOut;
var $e1f47da364eecfa1$export$2e2bcd8739ae039 = $e1f47da364eecfa1$var$timingFunction;



let $6cd61fabd6b38d60$var$canvas = null;
/**
 * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.
 *
 * @param {String} text The text to be rendered.
 * @param {String} font The css font descriptor that text is to be rendered with (e.g. "bold 14px verdana").
 *
 * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393
 */ const $6cd61fabd6b38d60$var$getTextWidth = (text, font)=>{
    if (!$6cd61fabd6b38d60$var$canvas) $6cd61fabd6b38d60$var$canvas = document.createElement('canvas');
    const context = $6cd61fabd6b38d60$var$canvas.getContext('2d');
    context.font = font;
    const metrics = context.measureText(text);
    return metrics.width;
};
var $6cd61fabd6b38d60$export$2e2bcd8739ae039 = $6cd61fabd6b38d60$var$getTextWidth;


const $2d4709caad7616c6$var$sliceTextByMaxWidth = (text, font, maxWidth)=>{
    const width = $6cd61fabd6b38d60$export$2e2bcd8739ae039(text, font);
    if (width < maxWidth) return text;
    let beginCursor = 0;
    let endCursor = text.length;
    let cursor = Math.floor(text.length / 2);
    // eslint-disable-next-line no-constant-condition
    while(true){
        const textSlice = `${text.slice(0, cursor)}...`;
        const w = $6cd61fabd6b38d60$export$2e2bcd8739ae039(textSlice, font);
        if (w > maxWidth) endCursor = cursor;
        else beginCursor = cursor;
        // middle between the beginCursor and the endCursor
        cursor = beginCursor + Math.floor((endCursor - beginCursor) / 2);
        if (beginCursor === cursor) return textSlice;
    }
};
var $2d4709caad7616c6$export$2e2bcd8739ae039 = $2d4709caad7616c6$var$sliceTextByMaxWidth;


const $a0bd24525d807451$var$getSegmentIndexByAngle = (/** Angle from 0 to Math.PI * 2 */ rotationAngle, segmentAngle)=>{
    // TODO:
    const normalizedAngle = Math.abs(rotationAngle % (Math.PI * 2) - Math.PI * 2) + Math.PI;
    return Math.floor(normalizedAngle % (Math.PI * 2) / segmentAngle);
};
var $a0bd24525d807451$export$2e2bcd8739ae039 = $a0bd24525d807451$var$getSegmentIndexByAngle;



const $c7f427153d308180$var$getDevicePixelRatio = ()=>typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1
;
var $c7f427153d308180$export$2e2bcd8739ae039 = $c7f427153d308180$var$getDevicePixelRatio;


const $cc97d80a69d0226c$var$useDevicePixelRatio = ()=>{
    const [scale, setScale] = $hqOIc$react.useState($c7f427153d308180$export$2e2bcd8739ae039);
    $hqOIc$react.useEffect(()=>{
        const handleResize = ()=>setScale($c7f427153d308180$export$2e2bcd8739ae039())
        ;
        window.addEventListener("resize", handleResize);
        return ()=>window.removeEventListener("resize", handleResize)
        ;
    }, []);
    return scale;
};
var $cc97d80a69d0226c$export$2e2bcd8739ae039 = $cc97d80a69d0226c$var$useDevicePixelRatio;


const $082c0c4a773616d1$var$GLOBAL_FONT = "Roboto, Helvetica, Arial, sans-serif";
const $082c0c4a773616d1$var$normalizeSegments = (segments, textFont, maxTextWidth)=>segments.map(({ title: title , ...rest })=>({
            title: $2d4709caad7616c6$export$2e2bcd8739ae039(title, textFont, maxTextWidth),
            ...rest
        })
    )
;
const $082c0c4a773616d1$var$getTextFont = (radius)=>`${0.06 * radius}px ${$082c0c4a773616d1$var$GLOBAL_FONT}`
;
const $082c0c4a773616d1$var$defaultWheelColors = {
    wheelBackground: "#fff",
    text: "rgba(0, 0, 0, 0.87)",
    border: "#424242"
};
const $082c0c4a773616d1$var$SpinningWheel = ({ size: size , segments: segments , wheelColors: wheelColors = $082c0c4a773616d1$var$defaultWheelColors , spinningWheelRef: spinningWheelRef , timingFunction: timingFunction = $e1f47da364eecfa1$export$2e2bcd8739ae039 , onSegmentChange: onSegmentChange = ()=>{
} , onSpinStart: onSpinStart = ()=>{
} , onSpinEnd: onSpinEnd = ()=>{
}  })=>{
    const [cachedWheel, setCachedWheel] = $hqOIc$react.useState(null);
    const cachedWheelRef = $hqOIc$react.useRef(null);
    cachedWheelRef.current = cachedWheel;
    const functions = $hqOIc$react.useRef({
        onSegmentChange: onSegmentChange,
        onSpinStart: onSpinStart,
        onSpinEnd: onSpinEnd
    });
    functions.current = {
        onSegmentChange: onSegmentChange,
        onSpinStart: onSpinStart,
        onSpinEnd: onSpinEnd
    };
    const rotationAngle = $hqOIc$react.useRef(0);
    const requestId = $hqOIc$react.useRef(null);
    const currentSegmentIndex = $hqOIc$react.useRef(0);
    const prevTime = $hqOIc$react.useRef(null);
    const fullTime = $hqOIc$react.useRef(0);
    const radius = size / 2;
    const scale = $cc97d80a69d0226c$export$2e2bcd8739ae039();
    $hqOIc$react.useEffect(()=>{
        const canvas = document.createElement("canvas");
        const textFont = $082c0c4a773616d1$var$getTextFont(radius);
        const textMaxWidth = 0.675 * radius;
        const wheel = $74c20d64a5d4a0af$export$2e2bcd8739ae039({
            canvas: canvas,
            segments: $082c0c4a773616d1$var$normalizeSegments(segments, textFont, textMaxWidth),
            size: size,
            scale: scale,
            textFont: textFont,
            wheelColors: wheelColors
        });
        setCachedWheel(wheel);
    }, [
        size,
        radius,
        segments,
        wheelColors,
        scale
    ]);
    // https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node
    const canvasRef = $hqOIc$react.useCallback((canvas)=>{
        if (!canvas || !cachedWheel) return;
        const ctx = canvas.getContext("2d");
        const segmentAngle = $77ad3b2cb2ddb8e0$export$2e2bcd8739ae039(segments.length);
        canvas.width = size * scale;
        canvas.height = size * scale;
        if (requestId.current === null) window.requestAnimationFrame(()=>{
            $746eff0e043c15c9$export$2e2bcd8739ae039({
                ctx: ctx,
                canvasToRender: cachedWheel,
                size: size,
                scale: scale,
                rotationAngle: rotationAngle.current
            });
        });
        if (!spinningWheelRef) return;
        const animate = (secondsToSpin, speed)=>(time)=>{
                // first draw
                if (prevTime.current === null) {
                    currentSegmentIndex.current = $a0bd24525d807451$export$2e2bcd8739ae039(rotationAngle.current, segmentAngle);
                    prevTime.current = time;
                }
                const deltaTime = time - prevTime.current;
                prevTime.current = time;
                fullTime.current += deltaTime;
                if (fullTime.current > secondsToSpin * 1000) {
                    functions.current.onSpinEnd(currentSegmentIndex.current);
                    stopSpinning();
                    return;
                }
                const thisSegmentIndex = $a0bd24525d807451$export$2e2bcd8739ae039(rotationAngle.current, segmentAngle);
                if (currentSegmentIndex.current !== thisSegmentIndex) {
                    currentSegmentIndex.current = thisSegmentIndex;
                    functions.current.onSegmentChange(thisSegmentIndex);
                }
                // NOTE: in "variableI" letter "I" means UnitInterval - [0, 1)
                const timeI = fullTime.current / (secondsToSpin * 1000);
                const speedI = timingFunction(timeI);
                const deltaAngle = 2 * Math.PI / 360 * speedI * speed;
                rotationAngle.current += deltaAngle;
                $746eff0e043c15c9$export$2e2bcd8739ae039({
                    ctx: ctx,
                    canvasToRender: cachedWheelRef.current,
                    size: size,
                    scale: scale,
                    rotationAngle: rotationAngle.current
                });
                requestId.current = window.requestAnimationFrame(animate(secondsToSpin, speed));
            }
        ;
        function startSpinning(secondsToSpin, speed) {
            functions.current.onSpinStart();
            rotationAngle.current = 0;
            currentSegmentIndex.current = 0;
            prevTime.current = null;
            fullTime.current = 0;
            requestId.current = window.requestAnimationFrame(animate(secondsToSpin, speed));
        }
        function stopSpinning() {
            if (requestId.current) window.cancelAnimationFrame(requestId.current);
            requestId.current = null;
        }
        spinningWheelRef.current = {
            startSpinning: startSpinning,
            stopSpinning: stopSpinning
        };
    }, [
        cachedWheel
    ]);
    return(/*#__PURE__*/ $hqOIc$reactjsxruntime.jsx("canvas", {
        width: size,
        height: size,
        style: {
            width: size,
            height: size
        },
        ref: canvasRef
    }));
};
var $082c0c4a773616d1$export$2e2bcd8739ae039 = $082c0c4a773616d1$var$SpinningWheel;



var $926f150b8c018491$exports = {};


$parcel$exportWildcard(module.exports, $082c0c4a773616d1$exports);
$parcel$exportWildcard(module.exports, $926f150b8c018491$exports);


//# sourceMappingURL=main.js.map
